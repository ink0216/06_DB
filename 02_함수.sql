-- 함수 : 컬럼값 | 지정된값을 읽어 연산한 결과를 반환하는 것

-- 단일행 함수 : N개의 행의 컬럼 값을 전달하여 N개의 결과가 반환

-- 그룹 함수  : N개의 행의 컬럼 값을 전달하여 1개의 결과가 반환
--			  (그룹의 수가 늘어나면 그룹의 수 만큼 결과를 반환)

-- 함수는 SELECT절, WHERE절, ORDER BY절
--      GROUP BY절, HAVING절에서 사용 가능(FROM절에서는 사용불가)

/********************* 단일행 함수 *********************/
-- <문자열 관련 함수>

-- LENGTH(문자열|컬럼명) : 문자열의 길이 반환
SELECT 'HELLO WORLD', LENGTH('HELLO WORLD') FROM DUAL;
--ORACLE에서 문자열 : ''
-----------------------------------------------------------------
-- EMPLOYEE 테이블에서
-- 사원명, 이메일, 이메일 길이 조회
-- 단, 이메일 길이가 12 이하인 행만 
-- 이메일 길이 오름차순 조회 
SELECT EMP_NAME, EMAIL, LENGTH('EMAIL') "이메일 길이"
--쌍따옴표는 그 안에 작성된 그대로로 인식하라는 뜻!!(문자열 아님)
FROM EMPLOYEE
WHERE LENGTH(EMAIL)<=12
ORDER BY "이메일 길이";
----------------------------------------------
-- INSTR(문자열 | 컬럼명, '찾을 문자열' [, 찾을 시작 위치 [, 순번]]) 
--문자열 안에 어디에 위치하고 있는지(문자열 안에서 원하는 문자의 위치 찾기)(IN STRING)
-- 찾을 시작 위치부터 지정된 순번째 찾은 문자열의 시작 위치를 반환

-- 문자열에서 맨 앞에있는 'B'의 위치를 조회하기
SELECT 'AABAACAABBAA', INSTR('AABAACAABBAA', 'B') 
FROM DUAL; --인덱스(0부터 시작)가 아닌, 위치 카운트(3번째)
------------------------------------------------------------------
-- 문자열에서 5번 부터 검색 시작해서 처음 찾은 'B'의 위치 조회하기-->9번 나올거임
SELECT 'AABAACAABBAA', INSTR('AABAACAABBAA', 'B', 5) 
FROM DUAL; --5번 부터 세면, 처음 나오는 B가 9번에 나옴
------------------------------------------------------------------
-- 문자열에서 5번 부터 검색 시작해서 두 번째로 찾은 'B'의 위치 조회하기-->10번 나올거임
SELECT 'AABAACAABBAA', INSTR('AABAACAABBAA', 'B', 5, 2) 
FROM DUAL; --5번 부터 세서 2번째를 찾을 거다
------------------------------------------------------------------
-- SUBSTR(문자열 | 컬럼명, 시작위치 [,길이])
-- SUB=빼기 SUB STRING (문자열을 잘라서 빼내기)

-- 문자열을 시작 위치부터 지정된 길이 만큼 잘라내서 반환
-- 길이 미작성 시 시작 위치 부터 끝까지 잘라내서 반환
------------------------------------------------------------------
--시작 위치, 종료 길이 지정해서 해보기
SELECT SUBSTR('ABCDEFG', 2, 3)--2번째에서 시작해서 3칸만큼 자르겠다(BCD)
FROM DUAL;
------------------------------------------------------------------
--시작 위치 지정, 종료 길이 미지정
SELECT SUBSTR('ABCDEFG', 4) FROM DUAL;--DEFG
------------------------------------------------------------------
-- EMPLOYEE 테이블에서 
-- 사원명, 이메일 아이디 (@ 앞에까지 문자열)을
-- 이메일 아이디 오름차순으로 조회
SELECT EMP_NAME , 
SUBSTR(EMAIL, 1, INSTR(EMAIL, '@')-1) "이메일 아이디"
--INSTR(EMAIL, '@') : EMAIL에서 @의 위치 숫자 반환
FROM EMPLOYEE
ORDER BY SUBSTR(EMAIL, 1, INSTR(EMAIL, '@')-1);
------------------------------------------------------------------
-- TRIM([ [옵션] 문자열 | 컬럼명 FROM ] 문자열 | 컬럼명)
-- 주어진 문자열의 앞쪽|뒤쪽|양쪽에 존재하는 지정된 문자열을 제거
-- TRIM ==자르다(JS에서 양쪽 공백 제거)
-- 옵션 : LEADING(앞쪽), TRAILING(뒤쪽), BOTH(양쪽, 기본값)
------------------------------------------------------------------
--문자열 공백 제거
SELECT '   기  준   ', --이 문자열이 기준임
	TRIM(LEADING ' ' FROM '   기  준   '),
	--'   기  준   '이라는 문자열에서 앞쪽의 공백을 제거하기
	TRIM(TRAILING ' ' FROM '   기  준   '),
	--'   기  준   '이라는 문자열에서 뒷쪽의 공백을 제거하기(트레일러)
	TRIM(BOTH ' ' FROM '   기  준   ')
FROM DUAL;
	--'   기  준   '이라는 문자열에서 양쪽의 공백을 제거하기
------------------------------------------------------------------
--문자열에서 특정 문자열 제거
SELECT '###기  준###', --이 문자열이 기준임
	TRIM(LEADING '#' FROM '###기  준###'),
	--'###기  준###'이라는 문자열에서 앞쪽의 #을 제거하기
	TRIM(TRAILING '#' FROM '###기  준###'),
	--'###기  준###'이라는 문자열에서 뒷쪽의 #을 제거하기(트레일러)
	TRIM(BOTH '#' FROM '###기  준###')
FROM DUAL;
	--'   기  준   '이라는 문자열에서 양쪽의 #을 제거하기
	
	--CSS에서 FLOAT를 해제할 때 CLEAR : BOTH;했었음
------------------------------------------------------------------
-- REPLACE(문자열 | 컬럼명, 찾을 문자열, 바꿀 문자열)
SELECT * FROM NATIONAL; --이 중 한국을 대한민국으로 바꾸고 싶음
SELECT NATIONAL_CODE, REPLACE(NATIONAL_NAME, '한국', '대한민국')
FROM NATIONAL;
-----------------------------------------------------------------
--반올림, 올림, 내림, 절댓값, 나머지(%는 와일드카드여서 안쓰고 MOD씀) 구하기,
--<숫자 관련 함수>
--MOD(숫자 | 컬럼명, 나눌 값) : 나머지
SELECT MOD(105,100) FROM DUAL; --105/100한 나머지 --5 나옴

--ABS(숫자 | 컬럼명) : 절대값
SELECT ABS(10), ABS(-10) FROM DUAL; --둘다 10 나옴
-----------------------------------------------------------------
-- CEIL(숫자 | 컬럼명) : 올림(정수로만 가능)
-- FLOOR(숫자 | 컬럼명) : 내림(정수로만 가능)
SELECT CEIL(1.1), FLOOR(1.1) FROM DUAL; --2,1
-----------------------------------------------------------------
-- ROUND(숫자 | 컬럼명 [, 소수점 위치]) : 반올림
-- 소수점 위치 지정 x : 소수점 첫째 자리에서 반올림 -> 정수로 표현
-- 소수점 위치 지정 O
 -- 1) 양수 : 지정된 위치의 소수점 자리까지 표현해라
 -- 2) 음수 : 지정된 위치의 정수 자리까지 표현
-----------------------------------------------------------------
SELECT 123.456, 
ROUND(123.456),--반올림하는 위치 안적었으니까 소수 첫째 자리에서 반올림됨
-- == ROUND(123.456,0),--반올림하는 위치 안적었으니까 소수 첫째 자리에서 반올림됨
ROUND(123.456, 1),--반올림해서 소수 첫째 자리까지 보이게, 소수 둘째 자리에서 반올림
ROUND(123.456, 2),--반올림해서 소수 둘째 자리까지 보이게, 소수 셋재 자리에서 반올림
ROUND(123.456, -1),--반올림해서 10의 자리까지 보이게, 1의 자리에서 반올림
ROUND(123.456, -2)--반올림해서 100의 자리까지 보이게, 10의 자리에서 반올림
FROM DUAL;
-- TRUNC(숫자 | 컬럼명 [,소수점 위치]) : 버림 (잘라내기)
SELECT -123.5, 
TRUNC(-123.5),--소수점 버림(그냥 소수점만 떼버리고 앞은 그대로) -- -123
FLOOR(-123.5)--소수점 내림 -- -124
FROM DUAL;
--------------------------------------------------------------
--오라클의 자료형 : 문자열, 숫자, 날짜, 큰 데이터
--------------------------------------------------------------
--<날짜 관련 함수)
-- SYSDATE : 현재 시간
-- SYSTIMESTAMP : 현재 시간 (ms 포함, 표준시간대 포함(시차))
SELECT SYSDATE, SYSTIMESTAMP FROM DUAL; 
--------------------------------------------------------------
-- MONTHS_BETWEEN(날짜, 날짜) : 두 날짜 사이의 개월 수를 반환
--	(몇 달이 차이 나는지)
--> 반환값 중 정수 부분은 차이나는 개월 수가 됨
--앞의 것 - 뒤의 것
SELECT MONTHS_BETWEEN('2024-03-28',SYSDATE) FROM DUAL;
--**ORACLE은 자료형이 맞지 않는 상황이어도
--	작성된 값의 형태가 요구하는 자료형의 형태를 띄고 있으면
--	자동으로 형변환(PARSING, 데이터 타입 자체를 바꾸기)을 진행한다!!
-- '2024-03-28'는 DATE타입이 아닌, STRING 타입이지만 날짜 형식이므로 
-- 자동으로 '2024-03-28' -> TO_DATE('2024-03-28', 'YYYY-MM-DD')
--	이 코드(DATE 타입으로 바꾸는 코드)가 자동으로 실행된다
----------------------------------------------------------------
-- EMPLOYEE 테이블에서
-- 모든 사원의 사번, 이름, 입사일, N년차 조회하기
-- 입사하자마자 : 1년차
SELECT EMP_ID , EMP_NAME , HIRE_DATE , 
CEIL(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12 ) ||'년차' "N년차"
--|| : 연결연산자 ( != OR)
FROM EMPLOYEE;
-------------------------------------------------------------------------
--MONTHS_BETWEEN()은 윤년(2월 29일이 포함된 해) 계산이 자동으로 수행된다
-->일 단위 연산이 아닌, YEAR, MONTH 단위 계산 시 더 정확한 값을 얻어낼 수 있다!!!
-->일 단위는 MONTHS_BETWEEN 쓰면 불편하고 그냥 더하기 빼기 하면 됨
-------------------------------------------------------------------------
-- ADD_MONTHS(날짜, 숫자) : 날짜를 숫자만큼의 개월 수를 더하여 반환
-- (원래 같은 일 수 다음 달까지의 날짜까지의 일 수 계산 어려운데 이거 쓰면 다음 달 계산됨
SELECT SYSDATE, --2/27
SYSDATE+29, --3/27  
SYSDATE+29 +31, --4/27  

ADD_MONTHS(SYSDATE, 1),--3/27 
ADD_MONTHS(SYSDATE, 2)--4/27
--일 수 계산해서 더하는 것보다 그냥 1달 후, 2달 후 하는게 더 쉽다
FROM DUAL;
------------------------------------------------------------------------
--LAST_DAY(날짜) : 해당 월의 마지막 날짜를 반환
SELECT LAST_DAY(SYSDATE) FROM DUAL; 
--이번 달의 마지막 날은 며칠?29일!

SELECT LAST_DAY(ADD_MONTHS(SYSDATE,1)) FROM DUAL; 
--다음 달의 마지막 날은 며칠?31일!

SELECT LAST_DAY(SYSDATE)+1 --이번 달의 마지막 날에 하루 뒤로 구하면 됨!
, LAST_DAY(ADD_MONTHS(SYSDATE,1)) FROM DUAL;
--다음 달 첫 번째, 마지막 날짜 구하기
-------------------------------------------------------------------------
-- EXTRACT(YEAR | MONTH | DAY  FROM  날짜)
-- 지정된 날짜의 년 | 월 | 일을 추출하여 정수로 반환
-- EXTRACT : 뽑아내다, 추출하다
SELECT EXTRACT(YEAR FROM SYSDATE) 년,
				EXTRACT(MONTH FROM SYSDATE) 월,
				EXTRACT(DAY FROM SYSDATE) 일
FROM DUAL;
--------------------------------------------------------------
-- EMPLOYEE 테이블에서 2000년대에 입사한 사원의
-- 사번, 이름, 입사일을 이름 오름차순으로 조회하기
SELECT EMP_ID , EMP_NAME , HIRE_DATE 
FROM EMPLOYEE
WHERE EXTRACT(YEAR FROM HIRE_DATE)>=2000
ORDER BY EMP_NAME; --15명
-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

-- <형변환(Parsing) 함수>

-- 문자열(CHAR, VARCHAR2) <-> 숫자(NUMBER)
-- 문자열(CHAR, VARCHAR2) <-> 날짜(DATE)
-- 숫자(NUMBER) --> 날짜(DATE)
-- 날짜는 숫자로 바꿀 수 없음

/* TO_CHAR(날짜 | 숫자 [, 포맷]) : 문자열(CHAR+VARCHAR)로 변환
 * 
 * 숫자 -> 문자열
 * 포맷 
 * 1) 9 : 숫자 한 칸을 의미, 오른쪽 정렬
 * 2) 0 : 숫자 한 칸을 의미, 오른쪽 정렬, 빈 칸에 0을 추가
 * 3) L : 현재 시스템이나 DB에 설정된 나라의 화폐 기호
 * 4) , : 숫자의 자릿수 구분
 * */
--숫자를 문자열로 바꾸기
SELECT 1234, TO_CHAR(1234) FROM DUAL; -- 데이터 타입이 변경됨

SELECT 1234, TO_CHAR(1234, '99999999') FROM DUAL; --'    1234'
--네 칸짜리를 오른쪽 정렬해서 앞에 네 칸은 공백으로 출력

SELECT 1234, TO_CHAR(1234, '00000000') FROM DUAL; --'00001234'
--네 칸짜리를 오른쪽 정렬해서 앞에 네 칸의 공백에는 0 넣기

/*숫자->문자열 변환 시 문제 상황(TO_CHAR를 잘못 사용하는 경우)*/
--> 포맷에 지정된 칸 수가 숫자의 길이보다 적으면 전부 #으로 변환돼서 출력됨(자릿수 초과된 오류)
SELECT 1234, TO_CHAR(1234, '000') FROM DUAL; --####

--화폐 기호 + 자릿수 구분
SELECT TO_CHAR(123456789, 'L999999999'),--DB에 설정된 나라에 맞춰서 기호 지정됨
TO_CHAR(123456789,'$999,999,999')--원하는 기호 있으면 그거 쓰면 되고, 자릿수 ,도 가능하다
FROM DUAL;

--모든 사원의 연봉 예쁘게 조회하기
SELECT EMP_NAME , TO_CHAR(SALARY*12, 'L999,999,999') "연봉"
FROM EMPLOYEE;
-------------------------------------------------------------------------

/* 날짜 -> 문자열
 * 
 * <연도를 나타내는 게 두가지, Y/R>
 * YY    : 년도(짧게) EX) 23
 * YYYY  : 년도(길게) EX) 2023
 * 
 * RR    : 년도(짧게) EX) 23
 * RRRR  : 년도(길게) EX) 2023
 * 
 * MM : 월
 * DD : 일
 * 
 * AM/PM : 오전/오후
 * 
 * HH   : 시간 (12시간)
 * HH24 : 시간 (24시간)
 * MI   : 분
 * SS   : 초
 * 
 * DAY : 요일(전체) EX) 월요일, MONDAY
 * DY  : 요일(짧게) EX) 월, MON
 * */
--현재 날짜 -> '2024-02-27'로 변경하기
SELECT SYSDATE,
TO_CHAR(SYSDATE, 'YYYY-MM-DD') --지정한 것만 나오고 자료도 원하는 형태의 문자열로 바뀜
FROM DUAL;
-------------------------------------------------------------------------
--현재 날짜 -> '2024-02-27 화요일'로 변경하기
SELECT SYSDATE,
TO_CHAR(SYSDATE, 'YYYY-MM-DD DAY') --지정한 것만 나오고 자료도 원하는 형태의 문자열로 바뀜
FROM DUAL;
-------------------------------------------------------------------------
--현재 날짜 -> '24/02/27 (화) 오후 12:11:20'으로 바꾸기
SELECT SYSDATE,
TO_CHAR(SYSDATE, 'YY/MM/DD (DY) PM HH:MI:SS')
FROM DUAL;
-- 패턴에 쓴 /, (), :, -는 일반적으로 날짜 표기 시 사용하는 기호여서
			-->얘네들도 패턴으로 인식돼서 오류가 발생하지 않음!	
-------------------------------------------------------------------------
--현재 날자 -> '2024년 02월 27일 오후 12시 15분 30초'로 바꾸기 ->이건 오류날거임
--년, 월, 일 같은 한글 또는 날짜와 관련 없는 문자는 패턴으로 인식되지 않음
-->근데 그걸 패턴처럼 쓰는 방법 존재!!!!
--> 이러한 관련 없는 문자들을 ""(있는 그대로 인식하라는 뜻)로 감싸면 사용이 가능하다
SELECT SYSDATE,
--TO_CHAR(SYSDATE,'YYYY년 MM월 DD일 PM HH시 MI분 SS초')--오류남
TO_CHAR(SYSDATE,'YYYY"년" MM"월" DD"일" PM HH"시" MI"분" SS"초"')
FROM DUAL;
---------------------------------------------------------------------
-- TO_DATE(문자열 | 숫자 [, 포맷])
-- 문자열이나 숫자를 날짜로 바꿔주는 것!
-- 문자열 또는 숫자를 날짜 형식으로 변환
SELECT TO_DATE('2024-03-04')
--날짜 모양인 문자열이어서 자동으로 DATE 타입으로 형변환됨
--문자열이 날짜를 표현하는 형식이면 포맷 지정 없이도 바로 변경됨
FROM DUAL;
-----------------------------------------------------------------------
SELECT TO_DATE('04-03-2024', 'DD-MM-YYYY') --일,월,년 순서로 쓴거야
FROM DUAL;
-----------------------------------------------------------------------
SELECT TO_DATE('02월 27일 화요일 12시 24분',
							'MM"월" DD"일" DAY HH"시" MI"분"')--연도 없는 경우 현재 연도 적용(기본값)
								--한글 부분은 그냥 그 문자 그대로 취급해! 패턴 아니고!
FROM DUAL;
------------------------------------------------------------------------
--숫자->날짜 변경하기
SELECT TO_DATE(20240227, 'YYYYMMDD') FROM DUAL;
------------------------------------------------------------------------
/*** 연도 패턴  Y, R 차이점 ***/

-- 연도가 네 자리가 아닌, 두 자리만 작성되어있는 경우
-- YY인지 RR인지에 따라 어떤 것은 
-- 50 미만 : Y,R 둘 다 누락된 연도 앞부분에 현재 세기(21C == 2000년대) 추가
--					YY==RR
-- 50 이상 : Y : 현재 세기(2000년대) 추가
--		    R : 이전 세기(1900년대) 추가
--				56 -> YY==2056년, RR==1956년
------------------------------------------------------------------------
--50미만 확인 (이 때에는 YY와 RR 동일)
SELECT 
 TO_DATE('49-11-25', 'YY-MM-DD') "YY", --2049(현재 세기 나옴)
 TO_DATE('49-11-25', 'RR-MM-DD') "RR" --2049(현재 세기 나옴)
 FROM DUAL;
------------------------------------------------------------------------
--50이상 확인(이 때에는 YY와 RR 다름)
SELECT 
 TO_DATE('50-11-25', 'YY-MM-DD') "YY", --2050(현재 세기 나옴)
 TO_DATE('50-11-25', 'RR-MM-DD') "RR" --1950(이전 세기 나옴)
 FROM DUAL;
------------------------------------------------------------------------
-- TO_NUMBER(문자열 [,패턴]) : 문자열 -> 숫자 변환

SELECT TO_NUMBER('$1,500', '$9,999') 
--1500달러를 숫자 1500으로 바꾸기
FROM DUAL;
-------------------------------------------------------------------------
-------------------------------------------------------------------------
--<NULL 처리 연산자> : IS NULL / IS NOT NULL
--<NULL 처리 함수>
-- NVL(컬럼명, 컬럼 값이 NULL일 경우 변경할 값) (NULL VALUE)
-- 지정된 컬럼이 NULL일 경우에 지정된 다른 매개변수 값으로 바꾸겠다
-------------------------------------------------------------------------
-- EMPLOYEE 테이블에서 
-- 사번, 이름, 전화번호 조회
-- 단, 전화번호가 없으면(NULL) '없음' 으로 조회
SELECT EMP_ID , EMP_NAME , NVL(PHONE, '없음') 전화번호
FROM EMPLOYEE;
-------------------------------------------------------------------------
-- EMPLOYEE 테이블에서
-- 이름, 급여, 보너스(월급의 몇 퍼센트 인센티브) 조회
-- 보너스가 없으면 0으로 조회
SELECT EMP_NAME , SALARY, NVL(BONUS,0)
FROM EMPLOYEE;
-------------------------------------------------------------------------
--EMPLOYEE 테이블에서
--이름, 급여, 성과급(급여*보너스) 조회하기
--단, 성과급이 없으면 0으로 표시하도록 만들기
SELECT EMP_NAME , SALARY , SALARY*NVL(BONUS,0) "성과급"
--보너스가 NULL이면 그것과 숫자를 곱한 값도 NULL이 나옴
-->NULL과 산술연산(+,-,* 등등) 시 결과값도 무조건 NULL이 나옴
/*NULL == 값이 아예 없다*/
FROM EMPLOYEE;
-------------------------------------------------------------------------
-- NVL2(컬럼명, NULL이 아닌 경우 변경할 값  , NULL인 경우 변경할 값)
-- NULL이 아닐 때에도 처리 가능
-------------------------------------------------------------------------
-- EMPLOYEE 테이블에서
-- 사번, 이름, 전화번호 조회
-- 전화 번호가 없으면 '없음'
-- 전화 번호가 있으면 '010********' 형식으로 변경해서 조회
SELECT EMP_ID , EMP_NAME , NVL2(PHONE,
RPAD(SUBSTR(PHONE,1,3), LENGTH(PHONE), '*')
--전화번호 첫번째부터 세번째까지 잘라서 오른쪽의 빈 공간을 *로 채우겠다
--PADDING : 내용과 BORDER 사이의 간격
--RPAD() : RIGHT PADDING : 문자열 안에서 오른쪽 채우기
, '없음') 전화번호
FROM EMPLOYEE;
-------------------------------------------------------------------------
-- <선택 함수>
-- 여러 가지 경우에 따라 알맞은 결과를 선택하는 함수
-- 조건에 맞는 것만 선택해서 보여줌
-- (if, switch문과 비슷)

-- DECODE(컬럼명 | 계산식, 조건1, 결과1, 조건2, 결과2, ...[,아무것도 만족 X인 경우 실행할 것])
-- : switch문과 비슷 컬럼에 
-- 컬럼명 | 계산식의 값이 일치하는 조건이 있으면
-- 해당 조건 오른쪽에 작성된 결과가 반환된다.
-- 값이 딱딱 떨어지는 경우에 DECODE 사용
-- 범위로 나누고 싶으면 CASE라는 함수 사용
-------------------------------------------------------------
--EMPLOYEE 테이블에서
--모든 사원의 이름, 주민등록번호, 성별 조회 (뒷자리가 1,2로 시작하는 사람밖에 없음)
SELECT EMP_NAME, EMP_NO, 
DECODE(SUBSTR(EMP_NO, 8,1),'1','남자' ,'2', '여자') 성별
-- SUBSTR(EMP_NO, 8,1) 실행 시, '1' 또는'2'라는 문자열 반환됨
--문자열 자르기 : SUBSTR
FROM EMPLOYEE;
-------------------------------------------------------------------------
-- EMPLOYEE 테이블에서
-- 직급코드가 'J7'인 직원은 급여 + 급여의 10%
-- 직급코드가 'J6'인 직원은 급여 + 급여의 15%
-- 직급코드가 'J5'인 직원은 급여 + 급여의 20%
-- 나머지 직급코드의 직원은 급여 + 급여의 5%  지급
-- 사원명, 직급코드, 기존급여, 지급급여 조회
SELECT EMP_NAME , JOB_CODE , SALARY, 
DECODE(JOB_CODE , 
'J7', SALARY*1.1, 
'J6', SALARY*1.15, 
'J5', SALARY*1.2,
SALARY*1.05) "지급 급여"
FROM EMPLOYEE
ORDER BY JOB_CODE; --이건 그냥 내가 추가한거임
-------------------------------------------------------------------------
-- 값이 딱딱 떨어지는 경우에 DECODE 사용
-- 범위로 나누고 싶으면 CASE라는 함수 사용
-------------------------------------------------------------------------
-- CASE --- END
-- CASE구문 여기서 시작해서 여기서 끝날거야(END)
-- 처음의 WHEN == IF문
-- 그 뒤의 WHEN == ELSE IF문
-- CASE 
--	  WHEN 조건1 THEN 결과1
--	  WHEN 조건2 THEN 결과2
--	  WHEN 조건3 THEN 결과3
--	  ELSE 결과 --세 WHEN구문에 모두 해당 안되는 경우
-- END

-- DECODE는 계산식|컬럼 값이 딱 떨어지는 경우에만 사용 가능.
-- CASE는 계산식|컬럼 값을 범위로 지정할 수 있다.  --근데 CASE는 꼭 범위 아니어도 많이 쓸 수 있음
-------------------------------------------------------------------------

-- EMPLOYEE 테이블에서 사번, 이름, 급여, 구분, 직급코드를 조회(구분이라는 컬럼 만들기)
-- 구분은 받는 급여에 따라 초급, 중급, 고급으로 조회
-- 급여 500만 이상 = '고급'
-- 급여 300만 이상 ~ 500만 미만 = '중급'
-- 급여 300미만 = '초급'
-- 단, 부서코드가 D6, D9인 사원만 직급코드 오름차순으로 조회
/*3*/SELECT EMP_ID , EMP_NAME , SALARY , 
CASE
	WHEN SALARY>=5000000 THEN '고급'
	WHEN SALARY>=3000000 THEN '중급'
	ELSE '초급'
END
구분
,DEPT_CODE 직급코드
/*1*/FROM EMPLOYEE
/*2*/WHERE DEPT_CODE IN ('D6', 'D9')
/*4*/ORDER BY JOB_CODE; 
--SELECT절에 작성된 컬럼이 아니라고 해서 ORDER BY절에서 사용 못하는게 아님!!
--	(FROM 절에서 이미 해석돼서 사용 가능한 상태이다!! 조회 안하더라도 이미 해석된 자료여서) 
-------------------------------------------------------------------------

/************* 그룹 함수 *************/

--  N개의 행의 컬럼 값을 전달하여 1개의 결과가 반환
--	(그룹의 수가 늘어나면 그룹의 수 만큼 결과를 반환)
-- 결과 값이 하나만 반환되는 경우==그룹함수
-- 전체 평균, 최대값, 최솟값 등등처럼 행이 여러개이더라도 그걸 종합해서 결과값이 하나만 나오는 것
-------------------------------------------------------------------------
--SUM(숫자가 기록된 컬럼명) : 그룹의 합계를 반환

--모든 사원의 급여 합
SELECT SUM(SALARY) FROM EMPLOYEE;
-------------------------------------------------------------------------
--부서 코드가 'D6'인 사원들의 급여 합 구하기
/*3*/SELECT SUM(SALARY)				--3) SALARY 컬럼 값의 합을 조회하겠다
/*1*/FROM EMPLOYEE 						--1)EMPLOYEE 테이블 23행 중
/*2*/WHERE DEPT_CODE = 'D6'; -- 2) DEPT_CODE가 'D6'인 행만 모아서
-------------------------------------------------------------------------
--2000년대 입사자들의 급여 합 조회하기
SELECT SUM(SALARY)
FROM EMPLOYEE
WHERE EXTRACT(YEAR FROM HIRE_DATE)>=2000;
--EXTRACT() : 날짜 중에서 연,월,일을 정수 형태로 뽑아내는것
-------------------------------------------------------------------------
-- AVG(숫자만 기록된 컬럼) : 그룹의 평균을 반환

--모든 사원의 평균 급여 조회하기
SELECT AVG(SALARY)
FROM EMPLOYEE;

--모든 사원의 평균 급여 조회하기(소수점 내림)
SELECT FLOOR(AVG(SALARY))
FROM EMPLOYEE;
-------------------------------------------------------------------------
/*그룹 함수는 여러 개를 동시에 조회할 수 있다*/
SELECT SUM(SALARY), FLOOR(AVG(SALARY)) FROM EMPLOYEE;
-- 조회 결과가 사각형 형태의 테이블 모양일 경우에만 조회 가능하다!!
--SUM(SALARY) : 결과로 1행만 나옴
--FLOOR(AVG(SALARY)) : 결과로 1행만 나옴
-->이렇게 결과 행 개수가 같을 때에만 가능

--SELECT SALARY, FLOOR(AVG(SALARY)) FROM EMPLOYEE;
--SALARY : 결과로 23행 나옴
--FLOOR(AVG(SALARY)) : 결과로 1행만 나옴
-->결과의 행 개수 (==결과 수)
/*
 * ㅁㅁㅁ
 * ㅁㅁ
 * ㅁ
 * 3 2 1 이런식으로 결과값이 수가 다른 경우의 컬럼들은 함께 조회할 수 없음!!!(오류남) 
 * */
-- ORA-00937: 단일 그룹의 그룹 함수가 아닙니다
-------------------------------------------------------------------------
-- MAX(컬럼명) : 최대값
-- MIN(컬럼명) : 최소값

-- 날짜 대소 비교 : 과거 < 미래
-- 문자열 대소 비교 : 유니코드순서  (문자열 순서  A < Z)
-------------------------------------------------------------------------
-- 모든 사원 중
-- 가장 빠른 입사일, 최근 입사일
-- 이름 오름차순에서 제일 먼저 작성되는 이름, 마지막에 작성되는 이름
SELECT 
	MIN(HIRE_DATE), MAX(HIRE_DATE),
	MIN(EMP_NAME), MAX(EMP_NAME) --이 네개가 모두 1행으로 나와서 사각형 모양이라 문제 없음!!
FROM EMPLOYEE;
------------------------------------------------------------------------
-- COUNT(* | [DISTINCT] 컬럼명) : 조회된 행의 개수를 반환
-- 조회된 행이 몇 개인지 세어서 반환
-- COUNT(*) : 조회된 모든 행의 개수를 반환

-- COUNT(컬럼명) : 지정된 컬럼 값이 NULL이 아닌 행의 개수를 반환
-- 					(NULL인 행 미포함)

-- COUNT(DISTINCT 컬럼명) : 중복 제거!!(서로 다른 것이 몇 개인지 카운트함 )
	-- 지정된 컬럼에서 중복 값을 제외한 행의 개수를 반환
	-- EX) A A B C D D D E : 5개 (중복은 한 번만 카운트)
------------------------------------------------------------------------
--EMPLOYEE 테이블 전체 행의 개수
SELECT COUNT(*) FROM EMPLOYEE; --23행이라는 뜻

--EMPLOYEE 테이블에서 부서 코드가 'D5'인 사원의 수 조회하기
SELECT COUNT(*)
FROM EMPLOYEE
WHERE DEPT_CODE='D5'; --6명==6행
--EMPLOYEE 테이블 23행 중에 부서코드가 D5인 행들만 추려내서 그 행들의 수를 셈
-----------------------------------------------------------------------
--전화번호가 있는 사원의 수 V1
SELECT COUNT(*)
FROM EMPLOYEE
WHERE PHONE IS NOT NULL; --20명 ==20행
--NULL : JS/JAVA에서는 참조하는 객체가 없다, DB에서는 값이 없다
-----------------------------------------------------------------------
--전화번호가 있는 사원의 수 V2 == V1보다 이게 더 효율적임!
SELECT COUNT(PHONE) FROM EMPLOYEE; --20명 ==20행 (NULL인 애는 자동으로 안 셈)
-->NULL이 아닌 행의 수만 카운트
-----------------------------------------------------------------------
-- EMPLOYEE 테이블에 존재하는 부서코드의 수를 조회
-- (EMPLOYEE 테이블에 부서코드가 몇종류?)
SELECT COUNT(DISTINCT DEPT_CODE) FROM EMPLOYEE; 
--7행 나와야 할 것 같은데 NULL인 행은 자동으로 안 세서 6행 나옴
--COUNT() 내에 컬럼명을 작성하면 NULL은 제외하고 셈
-----------------------------------------------------------------------
-- EMPLOYEE 테이블에 존재하는 여자 사원의 수
SELECT COUNT(*)
FROM EMPLOYEE 
WHERE SUBSTR(EMP_NO, 8,1)='2'; --8명

-- EMPLOYEE 테이블에 존재하는 남자 사원의 수
SELECT COUNT(*)
FROM EMPLOYEE 
WHERE SUBSTR(EMP_NO, 8,1)='1'; --15명
-----------------------------------------------------------------------
--EMPLOYEE 테이블에 존재하는 여자, 남자 사원의 수를 한 테이블에 함께 나타내기(COUNT버전)
--여기서는 DECODE를 써야 함
SELECT COUNT(DECODE(SUBSTR(EMP_NO, 8,1), '2', '여자', NULL)) "여자 카운트",
				COUNT(DECODE(SUBSTR(EMP_NO, 8,1), '1', '남자', NULL)) "남자 카운트"
--나머지는 NULL로 한 후 카운트하면 나머지는 NULL이어서 카운트에 세지지 않음
FROM EMPLOYEE;
-----------------------------------------------------------------------
--EMPLOYEE 테이블에 존재하는 여자, 남자 사원의 수를 한 테이블에 함께 나타내기(SUM버전)
SELECT --여자의 수(여자 한명당 1씩 더함) , 0은 아무리 더해도 안 더해진 것과 같음
	SUM(DECODE(SUBSTR(EMP_NO, 8,1), '2',1,0)) "여자 카운트",  
	SUM(DECODE(SUBSTR(EMP_NO, 8,1), '1',1,0)) "남자 카운트"  
FROM EMPLOYEE;
-----------------------------------------------------------------------




